{"ast":null,"code":"var debug = AFRAME.utils.debug;\nvar coordinates = AFRAME.utils.coordinates;\nvar warn = debug('components:look-at:warn');\nvar isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;\ndelete AFRAME.components['look-at'];\n/**\n * Look-at component.\n *\n * Modifies rotation to either track another entity OR do a one-time turn towards a position\n * vector.\n *\n * If tracking an object via setting the component value via a selector, look-at will register\n * a behavior to the scene to update rotation on every tick.\n */\n\nAFRAME.registerComponent('look-at', {\n  schema: {\n    \"default\": '0 0 0',\n    parse: function parse(value) {\n      // A static position to look at.\n      if (isCoordinates(value) || typeof value === 'object') {\n        return coordinates.parse(value);\n      } // A selector to a target entity.\n\n\n      return value;\n    },\n    stringify: function stringify(data) {\n      if (typeof data === 'object') {\n        return coordinates.stringify(data);\n      }\n\n      return data;\n    }\n  },\n  init: function init() {\n    this.target3D = null;\n    this.vector = new THREE.Vector3();\n    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);\n    this.el.addEventListener('componentinitialized', this.cameraListener);\n    this.el.addEventListener('componentremoved', this.cameraListener);\n  },\n\n  /**\n   * If tracking an object, this will be called on every tick.\n   * If looking at a position vector, this will only be called once (until further updates).\n   */\n  update: function update() {\n    var self = this;\n    var target = self.data;\n    var targetEl; // No longer looking at anything (i.e., look-at=\"\").\n\n    if (!target || typeof target === 'object' && !Object.keys(target).length) {\n      return self.remove();\n    } // Look at a position.\n\n\n    if (typeof target === 'object') {\n      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));\n    } // Assume target is a string.\n    // Query for the element, grab its object3D, then register a behavior on the scene to\n    // track the target on every tick.\n\n\n    targetEl = self.el.sceneEl.querySelector(target);\n\n    if (!targetEl) {\n      warn('\"' + target + '\" does not point to a valid entity to look-at');\n      return;\n    }\n\n    if (!targetEl.hasLoaded) {\n      return targetEl.addEventListener('loaded', function () {\n        self.beginTracking(targetEl);\n      });\n    }\n\n    return self.beginTracking(targetEl);\n  },\n  tick: function () {\n    var vec3 = new THREE.Vector3();\n    return function (t) {\n      // Track target object position. Depends on parent object keeping global transforms up\n      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.\n      var target3D = this.target3D;\n\n      if (target3D) {\n        target3D.getWorldPosition(vec3);\n        this.lookAt(vec3);\n      }\n    };\n  }(),\n  remove: function remove() {\n    this.el.removeEventListener('componentinitialized', this.cameraListener);\n    this.el.removeEventListener('componentremoved', this.cameraListener);\n  },\n  beginTracking: function beginTracking(targetEl) {\n    this.target3D = targetEl.object3D;\n  },\n  cameraListener: function cameraListener(e) {\n    if (e.detail && e.detail.name === 'camera') {\n      this.update();\n    }\n  },\n  lookAt: function lookAt(position) {\n    var vector = this.vector;\n    var object3D = this.el.object3D;\n\n    if (this.el.getObject3D('camera')) {\n      // Flip the vector to -z, looking away from target for camera entities. When using\n      // lookat from THREE camera objects, this is applied for you, but since the camera is\n      // nested into a Object3D, we need to apply this manually.\n      vector.subVectors(object3D.position, position).add(object3D.position);\n    } else {\n      vector.copy(position);\n    }\n\n    object3D.lookAt(vector);\n  }\n});","map":{"version":3,"sources":["/home/antariksh/Rudra/git_repo/websiterudra/node_modules/aframe-look-at-component/index.js"],"names":["debug","AFRAME","utils","coordinates","warn","isCoordinates","isCoordinate","components","registerComponent","schema","parse","value","stringify","data","init","target3D","vector","THREE","Vector3","cameraListener","bind","el","addEventListener","update","self","target","targetEl","Object","keys","length","remove","lookAt","x","y","z","sceneEl","querySelector","hasLoaded","beginTracking","tick","vec3","t","getWorldPosition","removeEventListener","object3D","e","detail","name","position","getObject3D","subVectors","add","copy"],"mappings":"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","sourcesContent":["var debug = AFRAME.utils.debug;\nvar coordinates = AFRAME.utils.coordinates;\n\nvar warn = debug('components:look-at:warn');\nvar isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;\n\ndelete AFRAME.components['look-at'];\n\n/**\n * Look-at component.\n *\n * Modifies rotation to either track another entity OR do a one-time turn towards a position\n * vector.\n *\n * If tracking an object via setting the component value via a selector, look-at will register\n * a behavior to the scene to update rotation on every tick.\n */\nAFRAME.registerComponent('look-at', {\n  schema: {\n    default: '0 0 0',\n\n    parse: function (value) {\n      // A static position to look at.\n      if (isCoordinates(value) || typeof value === 'object') {\n        return coordinates.parse(value);\n      }\n      // A selector to a target entity.\n      return value;\n    },\n\n    stringify: function (data) {\n      if (typeof data === 'object') {\n        return coordinates.stringify(data);\n      }\n      return data;\n    }\n  },\n\n  init: function () {\n    this.target3D = null;\n    this.vector = new THREE.Vector3();\n    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);\n    this.el.addEventListener('componentinitialized', this.cameraListener);\n    this.el.addEventListener('componentremoved', this.cameraListener);\n  },\n\n  /**\n   * If tracking an object, this will be called on every tick.\n   * If looking at a position vector, this will only be called once (until further updates).\n   */\n  update: function () {\n    var self = this;\n    var target = self.data;\n    var targetEl;\n\n    // No longer looking at anything (i.e., look-at=\"\").\n    if (!target || (typeof target === 'object' && !Object.keys(target).length)) {\n      return self.remove();\n    }\n\n    // Look at a position.\n    if (typeof target === 'object') {\n      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));\n    }\n\n    // Assume target is a string.\n    // Query for the element, grab its object3D, then register a behavior on the scene to\n    // track the target on every tick.\n    targetEl = self.el.sceneEl.querySelector(target);\n    if (!targetEl) {\n      warn('\"' + target + '\" does not point to a valid entity to look-at');\n      return;\n    }\n    if (!targetEl.hasLoaded) {\n      return targetEl.addEventListener('loaded', function () {\n        self.beginTracking(targetEl);\n      });\n    }\n    return self.beginTracking(targetEl);\n  },\n\n  tick: (function () {\n    var vec3 = new THREE.Vector3();\n\n    return function (t) {\n      // Track target object position. Depends on parent object keeping global transforms up\n      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.\n      var target3D = this.target3D;\n      if (target3D) {\n        target3D.getWorldPosition(vec3);\n        this.lookAt(vec3);\n      }\n    }\n  })(),\n\n  remove: function () {\n    this.el.removeEventListener('componentinitialized', this.cameraListener);\n    this.el.removeEventListener('componentremoved', this.cameraListener);\n  },\n\n  beginTracking: function (targetEl) {\n    this.target3D = targetEl.object3D;\n  },\n\n  cameraListener: function (e) {\n    if (e.detail && e.detail.name === 'camera') {\n      this.update();\n    }\n  },\n\n  lookAt: function (position) {\n    var vector = this.vector;\n    var object3D = this.el.object3D;\n\n    if (this.el.getObject3D('camera')) {\n      // Flip the vector to -z, looking away from target for camera entities. When using\n      // lookat from THREE camera objects, this is applied for you, but since the camera is\n      // nested into a Object3D, we need to apply this manually.\n      vector.subVectors(object3D.position, position).add(object3D.position);\n    } else {\n      vector.copy(position);\n    }\n\n    object3D.lookAt(vector);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}